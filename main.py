import argparse
import os
import sys
import copy

# Import functions from the new modules (relative imports within the src package)
from src.clang_format_parser import get_clang_format_options, parse_clang_format_options, generate_clang_format_config
from src.config_loader import load_json_option_values, load_forced_options
from src.optimizer import optimize_options_recursively

# Global debug flag (will be set from args)
DEBUG = False

def find_options_without_json_values(current_options_dict, json_options_lookup, forced_options_lookup, missing_list, current_path=""):
    """
    Recursively finds options in the dump-config structure that are not in the
    JSON lookup or have no possible values listed (excluding booleans which are auto-tested).
    Also excludes options that are present in the forced_options_lookup.

    Args:
        current_options_dict (dict): The dictionary currently being processed.
        json_options_lookup (dict): The flat dictionary from the JSON file.
        forced_options_lookup (dict): The flat dictionary from the forced options YAML file.
        missing_list (list): The list to append missing option names to.
        current_path (str): The dot-separated path to the current dictionary (e.g., "Parent.SubOption").
    """
    if not isinstance(current_options_dict, dict):
        return # Stop recursion if not a dictionary

    for option_name, option_info in current_options_dict.items():
        # Construct the full path for the current option
        full_option_path = f"{current_path}.{option_name}" if current_path else option_name

        if option_info['type'] == 'dict':
            # Recurse into nested dictionary, passing the updated full path
            find_options_without_json_values(option_info['value'], json_options_lookup, forced_options_lookup, missing_list, full_option_path)
        else:
            # Check if the option is in the JSON lookup and has possible values
            # OR if it's a boolean (which is handled automatically)
            # AND if it's NOT in the forced options lookup
            if (option_name not in json_options_lookup or not json_options_lookup[option_name]['possible_values']) and \
               (full_option_path not in forced_options_lookup): # <-- New condition here
                # If not in JSON or no values in JSON, check if it's a boolean
                if option_info['type'] != 'bool':
                    # If it's not a boolean and not in JSON/no values, and not forced, add its full path to missing list
                    missing_list.append(full_option_path)
                # If it *is* a boolean and not in JSON/no values, it will be auto-tested, so don't add to missing list


def main():
    """
    Parses command-line arguments and runs the clang-format optimization tool.
    """
    parser = argparse.ArgumentParser(
        description="Optimize clang-format configuration for a git repository."
    )
    parser.add_argument(
        "repo_path",
        help="Path to the git repository to analyze."
    )
    parser.add_argument(
        "--output",
        dest="output_file",
        help="Path to the file where the optimized configuration will be written (optional). If not provided, output is written to stdout."
    )
    parser.add_argument(
        "--option-values-json",
        dest="option_values_json_file",
        help="Path to a JSON file containing clang-format options and their possible values (generated by get_option_values.py)."
    )
    parser.add_argument(
        "--forced-options-yaml",
        dest="forced_options_yaml_file",
        help="Path to a YAML file containing options that should be forced to a specific value."
    )
    parser.add_argument(
        "-d", "--debug",
        action="store_true",
        help="Enable debug output (print commands being executed)."
    )

    args = parser.parse_args()

    # Set global debug flag
    global DEBUG
    DEBUG = args.debug

    # Basic validation
    if not os.path.isdir(args.repo_path):
        print(f"Error: Repository path '{args.repo_path}' is not a valid directory.", file=sys.stderr)
        exit(1)

    # Ensure the path is absolute for reliable chdir/restore
    repo_path_abs = os.path.abspath(args.repo_path)
    if not os.path.isdir(repo_path_abs):
         print(f"Error: Absolute repository path '{repo_path_abs}' is not a valid directory.", file=sys.stderr)
         exit(1)


    print(f"Analyzing repository: {repo_path_abs}", file=sys.stderr)

    # Get initial clang-format options structure
    options_output = get_clang_format_options(debug=DEBUG)

    if not options_output:
        print("\nFailed to retrieve clang-format options.", file=sys.stderr)
        exit(1)

    options_info = parse_clang_format_options(options_output)

    if not options_info:
        print("\nFailed to parse clang-format options.", file=sys.stderr)
        exit(1)

    print(f"\nSuccessfully parsed clang-format options structure.", file=sys.stderr)

    # Load external configurations
    json_options_lookup = load_json_option_values(args.option_values_json_file)
    forced_options_lookup = load_forced_options(args.forced_options_yaml_file)

    # Identify options missing from JSON or without possible values (excluding booleans)
    # and not present in forced options
    missing_options = []
    # Pass an empty string as the initial current_path for the root level
    find_options_without_json_values(options_info, json_options_lookup, forced_options_lookup, missing_options, "")

    if missing_options:
        print("\nThe following options were found in clang-format --dump-config but were not present in the provided JSON file or had no possible values listed (and are not booleans or forced options):", file=sys.stderr)
        for opt_path in missing_options: # opt_path now contains the full path
            print(f"- {opt_path}", file=sys.stderr)
        print("These options will retain their default values from --dump-config unless specified in the forced options YAML file.", file=sys.stderr)
    elif args.option_values_json_file:
         print("\nAll non-boolean options found in clang-format --dump-config were present in the provided JSON file with possible values, or were explicitly forced.", file=sys.stderr)
    else:
         print("\nNo JSON file with option values was provided. All non-boolean options will retain their default values from --dump-config unless specified in the forced options YAML file. Boolean options will be tested automatically.", file=sys.stderr)


    # Create a working copy of options to optimize
    # This copy will be modified recursively by the optimization functions
    optimized_options_info = copy.deepcopy(options_info)

    print("\nStarting optimization...", file=sys.stderr)

    # Start the recursive optimization process from the root
    optimize_options_recursively(optimized_options_info, repo_path_abs, optimized_options_info, json_options_lookup, forced_options_lookup, debug=DEBUG)

    print("\nOptimization complete.", file=sys.stderr)

    # Generate the final optimized configuration from the modified structure
    optimized_config = generate_clang_format_config(optimized_options_info)

    # Output the final configuration
    if args.output_file:
        print(f"\nWriting optimized configuration to: {args.output_file}", file=sys.stderr)
        try:
            with open(args.output_file, "w") as f:
                f.write(optimized_config)
            print("Optimized configuration written successfully.", file=sys.stderr)
        except IOError as e:
            print(f"Error writing to file {args.output_file}: {e}", file=sys.stderr)
            exit(1)
    else:
        print("\nOptimized configuration:", file=sys.stderr)
        print(optimized_config)


if __name__ == "__main__":
    # Note: To run this main script after moving, you should typically run it
    # as a module from the directory *above* src, like:
    # python -m src.main /path/to/repo
    main()
