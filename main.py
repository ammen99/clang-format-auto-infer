import argparse
import os
import sys
import tempfile # New import for temporary directories
import shutil # New import for copying/removing directories
import yaml # New import for loading YAML config files
import multiprocessing # New import for multiprocessing Manager and Value

# Import functions from the new modules (relative imports within the src package)
from src.clang_format_parser import get_clang_format_options, parse_clang_format_options, generate_clang_format_config
from src.config_loader import load_json_option_values, load_forced_options
from src.optimizer import GeneticAlgorithmOptimizer # Import the GA optimizer class
from src.nevergrad_optimizer import NevergradOptimizer # New import for Nevergrad optimizer class
from src.data_classes import OptimizationConfig, NevergradConfig, GeneticAlgorithmLookups # New import for data classes

# Global debug flag (will be set from args)
DEBUG = False

# Fixed random seed for reproducibility of file sampling
# This ensures that if file sampling is used, the same subset of files is chosen
# for fitness evaluation across different runs with the same parameters.
RANDOM_SEED = 42

def find_options_without_json_values(flat_options_info, json_options_lookup, forced_options_lookup, missing_list):
    """
    Finds options in the flat dump-config structure that are not in the
    JSON lookup or have no possible values listed (excluding booleans which are auto-tested).
    Also excludes options that are present in the forced_options_lookup.

    Args:
        flat_options_info (dict): The flat dictionary from parsed dump-config.
        json_options_lookup (dict): The flat dictionary from the JSON file.
        forced_options_lookup (dict): The flat dictionary from the forced options YAML file.
        missing_list (list): The list to append missing option names to.
    """
    for full_option_path, option_info in flat_options_info.items():
        # Check if the option is in the JSON lookup and has possible values
        # OR if it's a boolean (which is handled automatically)
        # AND if it's NOT in the forced options lookup
        if (full_option_path not in json_options_lookup or not json_options_lookup[full_option_path]['possible_values']) and \
           (full_option_path not in forced_options_lookup):
            # If not in JSON or no values in JSON, check if it's a boolean
            if option_info['type'] != 'bool':
                # If it's not a boolean and not in JSON/no values, and not forced, add its full path to missing list
                missing_list.append(full_option_path)
            # If it *is* a boolean and not in JSON/no values, it will be auto-tested, so don't add to missing list


def main():
    """
    Parses command-line arguments and runs the clang-format optimization tool.
    """
    parser = argparse.ArgumentParser(
        description="Optimize clang-format configuration for a git repository."
    )
    parser.add_argument(
        "repo_path",
        help="Path to the git repository to analyze."
    )
    parser.add_argument(
        "--output",
        dest="output_file",
        help="Path to the file where the optimized configuration will be written (optional). If not provided, output is written to stdout."
    )
    parser.add_argument(
        "--option-values-json",
        dest="option_values_json_file",
        help="Path to a JSON file containing clang-format options and their possible values (generated by get_option_values.py)."
    )
    parser.add_argument(
        "--forced-options-yaml",
        dest="forced_options_yaml_file",
        help="Path to a YAML file containing options that should be forced to a specific value."
    )
    parser.add_argument(
        "-d", "--debug",
        action="store_true",
        help="Enable debug output (print commands being executed)."
    )
    parser.add_argument(
        "--optimizer",
        choices=["genetic", "nevergrad"],
        default="genetic",
        help="Choose the optimization algorithm (genetic or nevergrad). Default: genetic."
    )
    # Genetic Algorithm specific arguments
    parser.add_argument(
        "--iterations",
        type=int,
        default=100,
        help="[Genetic Algorithm] Number of iterations (generations) for the genetic algorithm."
    )
    parser.add_argument(
        "--population-size",
        type=int,
        default=4, # Increased default for better GA performance with islands
        help="[Genetic Algorithm] Total number of individuals across all islands in the genetic algorithm population."
    )
    parser.add_argument(
        "--islands",
        type=int,
        default=1,
        help="[Genetic Algorithm] Number of independent populations (islands) for the genetic algorithm. Set to 1 for a single population."
    )
    parser.add_argument(
        "--plot-fitness",
        action="store_true",
        help="[Genetic Algorithm] Visualize the best fitness score over time for each island."
    )
    # Nevergrad specific arguments
    parser.add_argument(
        "--ng-budget",
        type=int,
        default=1000,
        help="[Nevergrad] Total number of evaluations (budget) for the Nevergrad optimizer."
    )
    parser.add_argument(
        "--ng-optimizer",
        type=str,
        default="OnePlusOne",
        help="[Nevergrad] Name of the Nevergrad optimizer to use (e.g., OnePlusOne, CMA, DE, PSO). See Nevergrad documentation for options."
    )
    parser.add_argument(
        "-j", "--jobs",
        type=int,
        default=1,
        help="Number of parallel jobs to run for fitness calculation. Each job uses a copy of the repository."
    )
    parser.add_argument(
        "--start-config-file",
        dest="start_config_file",
        help="Path to an existing .clang-format file to use as the starting configuration for optimization. If not provided, defaults from 'clang-format --dump-config' are used."
    )
    parser.add_argument(
        "--file-sample-percentage",
        type=float,
        default=100.0,
        help="Percentage of files to randomly sample for fitness calculation (0.0-100.0). Use a lower value for faster but less accurate optimization."
    )

    args = parser.parse_args()

    # Set global debug flag
    global DEBUG
    DEBUG = args.debug

    # Basic validation
    if not os.path.isdir(args.repo_path):
        print(f"Error: Repository path '{args.repo_path}' is not a valid directory.", file=sys.stderr)
        exit(1)

    # Ensure the path is absolute for reliable chdir/restore
    repo_path_abs = os.path.abspath(args.repo_path)
    if not os.path.isdir(repo_path_abs):
         print(f"Error: Absolute repository path '{repo_path_abs}' is not a valid directory.", file=sys.stderr)
         exit(1)


    print(f"Analyzing repository: {repo_path_abs}", file=sys.stderr)

    options_info = None
    if args.start_config_file:
        print(f"\nLoading initial configuration from: {args.start_config_file}", file=sys.stderr)
        if not os.path.exists(args.start_config_file):
            print(f"Error: Start config file '{args.start_config_file}' not found.", file=sys.stderr)
            exit(1)
        try:
            with open(args.start_config_file, 'r') as f:
                start_config_content = f.read()
            options_info = parse_clang_format_options(start_config_content)
            if not options_info:
                print(f"Error: Failed to parse YAML from '{args.start_config_file}'. Please ensure it's a valid .clang-format file.", file=sys.stderr)
                exit(1)
            print(f"Successfully loaded and parsed initial configuration from '{args.start_config_file}'.", file=sys.stderr)
        except IOError as e:
            print(f"Error reading start config file '{args.start_config_file}': {e}", file=sys.stderr)
            exit(1)
        except yaml.YAMLError as e:
            print(f"Error parsing YAML from '{args.start_config_file}': {e}", file=sys.stderr)
            exit(1)
    else:
        # Get initial clang-format options structure from dump-config
        print("\nGetting initial configuration from 'clang-format --dump-config'...", file=sys.stderr)
        options_output = get_clang_format_options(debug=DEBUG)

        if not options_output:
            print("\nFailed to retrieve clang-format options from --dump-config.", file=sys.stderr)
            exit(1)

        # Parse and flatten the options
        options_info = parse_clang_format_options(options_output)

        if not options_info:
            print("\nFailed to parse clang-format options from --dump-config.", file=sys.stderr)
            exit(1)

        print(f"\nSuccessfully parsed and flattened clang-format options structure from --dump-config.", file=sys.stderr)


    # Load external configurations (json_options_lookup is already flat)
    json_options_lookup = load_json_option_values(args.option_values_json_file)
    # Load and flatten forced options
    forced_options_lookup = load_forced_options(args.forced_options_yaml_file)

    # Create GeneticAlgorithmLookups object (used by both optimizers for option info)
    lookups = GeneticAlgorithmLookups(
        json_options_lookup=json_options_lookup,
        forced_options_lookup=forced_options_lookup
    )

    # Identify options missing from JSON or without possible values (excluding booleans)
    # and not present in forced options
    missing_options = []
    # Pass the flat options_info directly
    find_options_without_json_values(options_info, lookups.json_options_lookup, lookups.forced_options_lookup, missing_options)

    if missing_options:
        print("\nThe following options were found in the base config but were not present in the provided JSON file or had no possible values listed (and are not booleans or forced options):", file=sys.stderr)
        for opt_path in missing_options: # opt_path now contains the full path
            print(f"- {opt_path}", file=sys.stderr)
        print("These options will retain their values from the base config unless specified in the forced options YAML file.", file=sys.stderr)
    elif args.option_values_json_file:
         print("\nAll non-boolean options found in the base config were present in the provided JSON file with possible values, or were explicitly forced.", file=sys.stderr)
    else:
         print("\nNo JSON file with option values was provided. All non-boolean options will retain their values from the base config unless specified in the forced options YAML file. Boolean options will be tested automatically.", file=sys.stderr)


    num_jobs = args.jobs
    if num_jobs < 1:
        print("Error: Number of jobs must be at least 1. Setting to 1.", file=sys.stderr)
        num_jobs = 1

    temp_repo_paths = []
    print(f"\nPreparing {num_jobs} temporary copies of the repository for parallel processing...", file=sys.stderr)
    try:
        for i in range(num_jobs):
            # Create a unique temporary directory
            # Add process_id to prefix for clarity in debug logs
            temp_dir = tempfile.mkdtemp(prefix=f'clang_opt_repo_{i}_')
            print(f"  Copying '{repo_path_abs}' to '{temp_dir}'...", file=sys.stderr)
            # Copy contents of the original repo to the temporary directory
            # dirs_exist_ok=True is for Python 3.8+
            shutil.copytree(repo_path_abs, temp_dir, dirs_exist_ok=True)
            temp_repo_paths.append(temp_dir)
        print("Temporary repositories prepared.", file=sys.stderr)

        # No need for multiprocessing.Manager or shared counter for Nevergrad anymore
        # as the executor handles process management and repo path assignment is now
        # based on the worker's process ID directly.

        print("\nStarting optimization...", file=sys.stderr)

        optimized_options_info = None

        if args.optimizer == "genetic":
            # Create OptimizationConfig object for Genetic Algorithm
            opt_config = OptimizationConfig(
                num_iterations=args.iterations,
                total_population_size=args.population_size,
                num_islands=args.islands,
                debug=DEBUG,
                plot_fitness=args.plot_fitness
            )
            optimizer = GeneticAlgorithmOptimizer(opt_config) # Pass config to constructor
            optimized_options_info = optimizer.optimize(
                options_info, # Base configuration for population initialization
                temp_repo_paths, # Pass the list of temporary repo paths
                lookups, # Pass the lookups object
                args.file_sample_percentage, # Pass file sampling percentage
                RANDOM_SEED # Pass the fixed random seed
            )
        elif args.optimizer == "nevergrad":
            # Create NevergradConfig object
            ng_config = NevergradConfig(
                budget=args.ng_budget,
                optimizer_name=args.ng_optimizer,
                num_workers=num_jobs, # Nevergrad uses num_workers directly
                debug=DEBUG
            )
            optimizer = NevergradOptimizer(ng_config) # Pass config to constructor
            optimized_options_info = optimizer.optimize(
                options_info, # Base configuration for Nevergrad instrumentation
                temp_repo_paths, # Pass the list of temporary repo paths
                lookups, # Pass the lookups object
                args.file_sample_percentage, # Pass file sampling percentage
                RANDOM_SEED # Pass the fixed random seed
            )
        else:
            print(f"Error: Unknown optimizer '{args.optimizer}'.", file=sys.stderr)
            exit(1)

        print("\nOptimization complete.", file=sys.stderr)

        # Generate the final optimized configuration from the modified flat structure
        optimized_config = generate_clang_format_config(optimized_options_info)

        # Output the final configuration
        if args.output_file:
            print(f"\nWriting optimized configuration to: {args.output_file}", file=sys.stderr)
            try:
                with open(args.output_file, "w") as f:
                    f.write(optimized_config)
                print("Optimized configuration written successfully.", file=sys.stderr)
            except IOError as e:
                print(f"Error writing to file {args.output_file}: {e}", file=sys.stderr)
                exit(1)
        else:
            print("\nOptimized configuration:", file=sys.stderr)
            print(optimized_config)

    finally:
        print("\nCleaning up temporary repositories...", file=sys.stderr)
        for temp_dir in temp_repo_paths:
            try:
                if os.path.exists(temp_dir):
                    shutil.rmtree(temp_dir)
                    print(f"  Removed '{temp_dir}'.", file=sys.stderr)
            except OSError as e:
                print(f"Error removing temporary directory '{temp_dir}': {e}", file=sys.stderr)
        print("Cleanup complete.", file=sys.stderr)

        # No multiprocessing manager to shut down anymore

if __name__ == "__main__":
    # Note: To run this main script after moving, you should typically run it
    # as a module from the directory *above* src, like:
    # python -m src.main /path/to/repo
    main()
