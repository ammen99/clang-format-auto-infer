import argparse
import os
import sys
import copy

# Import functions from the new modules (relative imports within the src package)
from src.clang_format_parser import get_clang_format_options, parse_clang_format_options, generate_clang_format_config
from src.config_loader import load_json_option_values, load_forced_options
from src.optimizer import genetic_optimize_all_options # Changed import to the new GA function

# Global debug flag (will be set from args)
DEBUG = False

def find_options_without_json_values(flat_options_info, json_options_lookup, forced_options_lookup, missing_list):
    """
    Finds options in the flat dump-config structure that are not in the
    JSON lookup or have no possible values listed (excluding booleans which are auto-tested).
    Also excludes options that are present in the forced_options_lookup.

    Args:
        flat_options_info (dict): The flat dictionary from parsed dump-config.
        json_options_lookup (dict): The flat dictionary from the JSON file.
        forced_options_lookup (dict): The flat dictionary from the forced options YAML file.
        missing_list (list): The list to append missing option names to.
    """
    for full_option_path, option_info in flat_options_info.items():
        # Check if the option is in the JSON lookup and has possible values
        # OR if it's a boolean (which is handled automatically)
        # AND if it's NOT in the forced options lookup
        if (full_option_path not in json_options_lookup or not json_options_lookup[full_option_path]['possible_values']) and \
           (full_option_path not in forced_options_lookup):
            # If not in JSON or no values in JSON, check if it's a boolean
            if option_info['type'] != 'bool':
                # If it's not a boolean and not in JSON/no values, and not forced, add its full path to missing list
                missing_list.append(full_option_path)
            # If it *is* a boolean and not in JSON/no values, it will be auto-tested, so don't add to missing list


def main():
    """
    Parses command-line arguments and runs the clang-format optimization tool.
    """
    parser = argparse.ArgumentParser(
        description="Optimize clang-format configuration for a git repository."
    )
    parser.add_argument(
        "repo_path",
        help="Path to the git repository to analyze."
    )
    parser.add_argument(
        "--output",
        dest="output_file",
        help="Path to the file where the optimized configuration will be written (optional). If not provided, output is written to stdout."
    )
    parser.add_argument(
        "--option-values-json",
        dest="option_values_json_file",
        help="Path to a JSON file containing clang-format options and their possible values (generated by get_option_values.py)."
    )
    parser.add_argument(
        "--forced-options-yaml",
        dest="forced_options_yaml_file",
        help="Path to a YAML file containing options that should be forced to a specific value."
    )
    parser.add_argument(
        "-d", "--debug",
        action="store_true",
        help="Enable debug output (print commands being executed)."
    )
    parser.add_argument(
        "--iterations",
        type=int,
        default=10,
        help="Number of iterations (generations) for the genetic algorithm."
    )
    parser.add_argument(
        "--population-size",
        type=int,
        default=5,
        help="Maximum number of individuals in the genetic algorithm population."
    )

    args = parser.parse_args()

    # Set global debug flag
    global DEBUG
    DEBUG = args.debug

    # Basic validation
    if not os.path.isdir(args.repo_path):
        print(f"Error: Repository path '{args.repo_path}' is not a valid directory.", file=sys.stderr)
        exit(1)

    # Ensure the path is absolute for reliable chdir/restore
    repo_path_abs = os.path.abspath(args.repo_path)
    if not os.path.isdir(repo_path_abs):
         print(f"Error: Absolute repository path '{repo_path_abs}' is not a valid directory.", file=sys.stderr)
         exit(1)


    print(f"Analyzing repository: {repo_path_abs}", file=sys.stderr)

    # Get initial clang-format options structure
    options_output = get_clang_format_options(debug=DEBUG)

    if not options_output:
        print("\nFailed to retrieve clang-format options.", file=sys.stderr)
        exit(1)

    # Parse and flatten the options
    options_info = parse_clang_format_options(options_output)

    if not options_info:
        print("\nFailed to parse clang-format options.", file=sys.stderr)
        exit(1)

    print(f"\nSuccessfully parsed and flattened clang-format options structure.", file=sys.stderr)

    # Load external configurations (json_options_lookup is already flat)
    json_options_lookup = load_json_option_values(args.option_values_json_file)
    # Load and flatten forced options
    forced_options_lookup = load_forced_options(args.forced_options_yaml_file)

    # Identify options missing from JSON or without possible values (excluding booleans)
    # and not present in forced options
    missing_options = []
    # Pass the flat options_info directly
    find_options_without_json_values(options_info, json_options_lookup, forced_options_lookup, missing_options)

    if missing_options:
        print("\nThe following options were found in clang-format --dump-config but were not present in the provided JSON file or had no possible values listed (and are not booleans or forced options):", file=sys.stderr)
        for opt_path in missing_options: # opt_path now contains the full path
            print(f"- {opt_path}", file=sys.stderr)
        print("These options will retain their default values from --dump-config unless specified in the forced options YAML file.", file=sys.stderr)
    elif args.option_values_json_file:
         print("\nAll non-boolean options found in clang-format --dump-config were present in the provided JSON file with possible values, or were explicitly forced.", file=sys.stderr)
    else:
         print("\nNo JSON file with option values was provided. All non-boolean options will retain their default values from --dump-config unless specified in the forced options YAML file. Boolean options will be tested automatically.", file=sys.stderr)


    print("\nStarting genetic algorithm optimization...", file=sys.stderr)

    # Start the genetic algorithm optimization process
    optimized_options_info = genetic_optimize_all_options(
        options_info, # Base configuration for population initialization
        repo_path_abs,
        json_options_lookup,
        forced_options_lookup,
        num_iterations=args.iterations,
        max_individuals=args.population_size,
        debug=DEBUG
    )

    print("\nOptimization complete.", file=sys.stderr)

    # Generate the final optimized configuration from the modified flat structure
    optimized_config = generate_clang_format_config(optimized_options_info)

    # Output the final configuration
    if args.output_file:
        print(f"\nWriting optimized configuration to: {args.output_file}", file=sys.stderr)
        try:
            with open(args.output_file, "w") as f:
                f.write(optimized_config)
            print("Optimized configuration written successfully.", file=sys.stderr)
        except IOError as e:
            print(f"Error writing to file {args.output_file}: {e}", file=sys.stderr)
            exit(1)
    else:
        print("\nOptimized configuration:", file=sys.stderr)
        print(optimized_config)


if __name__ == "__main__":
    # Note: To run this main script after moving, you should typically run it
    # as a module from the directory *above* src, like:
    # python -m src.main /path/to/repo
    main()
