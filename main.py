import argparse
import os
import sys
import tempfile # New import for temporary directories
import shutil # New import for copying/removing directories
import yaml # New import for loading YAML config files

# Import functions from the new modules (relative imports within the src package)
from src.clang_format_parser import get_clang_format_options, parse_clang_format_options, generate_clang_format_config
from src.config_loader import load_json_option_values, load_forced_options
from src.optimizer import genetic_optimize_all_options # Changed import to the new GA function
from src.data_classes import OptimizationConfig, GeneticAlgorithmLookups # New import for data classes

# Global debug flag (will be set from args)
DEBUG = False

def find_options_without_json_values(flat_options_info, json_options_lookup, forced_options_lookup, missing_list):
    """
    Finds options in the flat dump-config structure that are not in the
    JSON lookup or have no possible values listed (excluding booleans which are auto-tested).
    Also excludes options that are present in the forced_options_lookup.

    Args:
        flat_options_info (dict): The flat dictionary from parsed dump-config.
        json_options_lookup (dict): The flat dictionary from the JSON file.
        forced_options_lookup (dict): The flat dictionary from the forced options YAML file.
        missing_list (list): The list to append missing option names to.
    """
    for full_option_path, option_info in flat_options_info.items():
        # Check if the option is in the JSON lookup and has possible values
        # OR if it's a boolean (which is handled automatically)
        # AND if it's NOT in the forced options lookup
        if (full_option_path not in json_options_lookup or not json_options_lookup[full_option_path]['possible_values']) and \
           (full_option_path not in forced_options_lookup):
            # If not in JSON or no values in JSON, check if it's a boolean
            if option_info['type'] != 'bool':
                # If it's not a boolean and not in JSON/no values, and not forced, add its full path to missing list
                missing_list.append(full_option_path)
            # If it *is* a boolean and not in JSON/no values, it will be auto-tested, so don't add to missing list


def main():
    """
    Parses command-line arguments and runs the clang-format optimization tool.
    """
    parser = argparse.ArgumentParser(
        description="Optimize clang-format configuration for a git repository."
    )
    parser.add_argument(
        "repo_path",
        help="Path to the git repository to analyze."
    )
    parser.add_argument(
        "--output",
        dest="output_file",
        help="Path to the file where the optimized configuration will be written (optional). If not provided, output is written to stdout."
    )
    parser.add_argument(
        "--option-values-json",
        dest="option_values_json_file",
        help="Path to a JSON file containing clang-format options and their possible values (generated by get_option_values.py)."
    )
    parser.add_argument(
        "--forced-options-yaml",
        dest="forced_options_yaml_file",
        help="Path to a YAML file containing options that should be forced to a specific value."
    )
    parser.add_argument(
        "-d", "--debug",
        action="store_true",
        help="Enable debug output (print commands being executed)."
    )
    parser.add_argument(
        "--iterations",
        type=int,
        default=100,
        help="Number of iterations (generations) for the genetic algorithm."
    )
    parser.add_argument(
        "--population-size",
        type=int,
        default=4, # Increased default for better GA performance with islands
        help="Total number of individuals across all islands in the genetic algorithm population."
    )
    parser.add_argument(
        "--islands",
        type=int,
        default=1,
        help="Number of independent populations (islands) for the genetic algorithm. Set to 1 for a single population."
    )
    parser.add_argument(
        "--plot-fitness",
        action="store_true",
        help="Visualize the best fitness score over time for each island."
    )
    parser.add_argument(
        "-j", "--jobs",
        type=int,
        default=1,
        help="Number of parallel jobs to run for fitness calculation. Each job uses a copy of the repository."
    )
    parser.add_argument(
        "--start-config-file",
        dest="start_config_file",
        help="Path to an existing .clang-format file to use as the starting configuration for optimization. If not provided, defaults from 'clang-format --dump-config' are used."
    )

    args = parser.parse_args()

    # Set global debug flag
    global DEBUG
    DEBUG = args.debug

    # Basic validation
    if not os.path.isdir(args.repo_path):
        print(f"Error: Repository path '{args.repo_path}' is not a valid directory.", file=sys.stderr)
        exit(1)

    # Ensure the path is absolute for reliable chdir/restore
    repo_path_abs = os.path.abspath(args.repo_path)
    if not os.path.isdir(repo_path_abs):
         print(f"Error: Absolute repository path '{repo_path_abs}' is not a valid directory.", file=sys.stderr)
         exit(1)


    print(f"Analyzing repository: {repo_path_abs}", file=sys.stderr)

    options_info = None
    if args.start_config_file:
        print(f"\nLoading initial configuration from: {args.start_config_file}", file=sys.stderr)
        if not os.path.exists(args.start_config_file):
            print(f"Error: Start config file '{args.start_config_file}' not found.", file=sys.stderr)
            exit(1)
        try:
            with open(args.start_config_file, 'r') as f:
                start_config_content = f.read()
            options_info = parse_clang_format_options(start_config_content)
            if not options_info:
                print(f"Error: Failed to parse YAML from '{args.start_config_file}'. Please ensure it's a valid .clang-format file.", file=sys.stderr)
                exit(1)
            print(f"Successfully loaded and parsed initial configuration from '{args.start_config_file}'.", file=sys.stderr)
        except IOError as e:
            print(f"Error reading start config file '{args.start_config_file}': {e}", file=sys.stderr)
            exit(1)
        except yaml.YAMLError as e:
            print(f"Error parsing YAML from '{args.start_config_file}': {e}", file=sys.stderr)
            exit(1)
    else:
        # Get initial clang-format options structure from dump-config
        print("\nGetting initial configuration from 'clang-format --dump-config'...", file=sys.stderr)
        options_output = get_clang_format_options(debug=DEBUG)

        if not options_output:
            print("\nFailed to retrieve clang-format options from --dump-config.", file=sys.stderr)
            exit(1)

        # Parse and flatten the options
        options_info = parse_clang_format_options(options_output)

        if not options_info:
            print("\nFailed to parse clang-format options from --dump-config.", file=sys.stderr)
            exit(1)

        print(f"\nSuccessfully parsed and flattened clang-format options structure from --dump-config.", file=sys.stderr)


    # Load external configurations (json_options_lookup is already flat)
    json_options_lookup = load_json_option_values(args.option_values_json_file)
    # Load and flatten forced options
    forced_options_lookup = load_forced_options(args.forced_options_yaml_file)

    # Create GeneticAlgorithmLookups object
    ga_lookups = GeneticAlgorithmLookups(
        json_options_lookup=json_options_lookup,
        forced_options_lookup=forced_options_lookup
    )

    # Identify options missing from JSON or without possible values (excluding booleans)
    # and not present in forced options
    missing_options = []
    # Pass the flat options_info directly
    find_options_without_json_values(options_info, ga_lookups.json_options_lookup, ga_lookups.forced_options_lookup, missing_options)

    if missing_options:
        print("\nThe following options were found in the base config but were not present in the provided JSON file or had no possible values listed (and are not booleans or forced options):", file=sys.stderr)
        for opt_path in missing_options: # opt_path now contains the full path
            print(f"- {opt_path}", file=sys.stderr)
        print("These options will retain their values from the base config unless specified in the forced options YAML file.", file=sys.stderr)
    elif args.option_values_json_file:
         print("\nAll non-boolean options found in the base config were present in the provided JSON file with possible values, or were explicitly forced.", file=sys.stderr)
    else:
         print("\nNo JSON file with option values was provided. All non-boolean options will retain their values from the base config unless specified in the forced options YAML file. Boolean options will be tested automatically.", file=sys.stderr)


    num_jobs = args.jobs
    if num_jobs < 1:
        print("Error: Number of jobs must be at least 1. Setting to 1.", file=sys.stderr)
        num_jobs = 1

    temp_repo_paths = []
    print(f"\nPreparing {num_jobs} temporary copies of the repository for parallel processing...", file=sys.stderr)
    try:
        for _ in range(num_jobs):
            # Create a unique temporary directory
            temp_dir = tempfile.mkdtemp(prefix='clang_opt_repo_')
            print(f"  Copying '{repo_path_abs}' to '{temp_dir}'...", file=sys.stderr)
            # Copy contents of the original repo to the temporary directory
            # dirs_exist_ok=True is for Python 3.8+
            shutil.copytree(repo_path_abs, temp_dir, dirs_exist_ok=True)
            temp_repo_paths.append(temp_dir)
        print("Temporary repositories prepared.", file=sys.stderr)

        print("\nStarting genetic algorithm optimization...", file=sys.stderr)

        # Create OptimizationConfig object
        opt_config = OptimizationConfig(
            num_iterations=args.iterations,
            total_population_size=args.population_size,
            num_islands=args.islands,
            debug=DEBUG,
            plot_fitness=args.plot_fitness
        )

        # Start the genetic algorithm optimization process
        optimized_options_info = genetic_optimize_all_options(
            options_info, # Base configuration for population initialization
            temp_repo_paths, # Pass the list of temporary repo paths
            ga_lookups, # Pass the lookups object
            opt_config # Pass the optimization config object
        )

        print("\nOptimization complete.", file=sys.stderr)

        # Generate the final optimized configuration from the modified flat structure
        optimized_config = generate_clang_format_config(optimized_options_info)

        # Output the final configuration
        if args.output_file:
            print(f"\nWriting optimized configuration to: {args.output_file}", file=sys.stderr)
            try:
                with open(args.output_file, "w") as f:
                    f.write(optimized_config)
                print("Optimized configuration written successfully.", file=sys.stderr)
            except IOError as e:
                print(f"Error writing to file {args.output_file}: {e}", file=sys.stderr)
                exit(1)
        else:
            print("\nOptimized configuration:", file=sys.stderr)
            print(optimized_config)

    finally:
        print("\nCleaning up temporary repositories...", file=sys.stderr)
        for temp_dir in temp_repo_paths:
            try:
                if os.path.exists(temp_dir):
                    shutil.rmtree(temp_dir)
                    print(f"  Removed '{temp_dir}'.", file=sys.stderr)
            except OSError as e:
                print(f"Error removing temporary directory '{temp_dir}': {e}", file=sys.stderr)
        print("Cleanup complete.", file=sys.stderr)


if __name__ == "__main__":
    # Note: To run this main script after moving, you should typically run it
    # as a module from the directory *above* src, like:
    # python -m src.main /path/to/repo
    main()
