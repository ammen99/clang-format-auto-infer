README.md
# Clang-Format Optimizer
This project provides a tool to automatically optimize `clang-format` configurations for a given C/C++/Objective-C git repository using a genetic algorithm. The
goal is to find a `.clang-format` configuration that minimizes the number of changes (insertions + deletions) when applied to the codebase, thereby reducing
formatting churn and improving code consistency.
## Features
*   **Genetic Algorithm Optimization**: Employs a genetic algorithm with an island model to explore a wide range of `clang-format` options and find an optimal
configuration.
*   **Configurable Options**: Utilizes a JSON file (generated from `clang-format` documentation) to understand possible values for various formatting options.
*   **Forced Options**: Allows users to specify certain `clang-format` options that should always be set to a particular value, overriding the optimization
process for those specific options.
*   **Change Minimization**: The fitness function for the genetic algorithm is based on minimizing the `git diff --shortstat` output (total insertions and
deletions) after applying `clang-format`.
*   **Interactive Plotting**: Optionally visualizes the fitness evolution of the genetic algorithm using `matplotlib`.
*   **Graceful Termination**: Supports `Ctrl-C` to gracefully stop the optimization process and return the best configuration found so far.
## Installation
### Prerequisites
Before you begin, ensure you have the following installed and available in your system's PATH:
*   **Python 3.x**: The project is developed in Python.
*   **clang-format**: The `clang-format` tool itself, which is part of the LLVM project. You can usually install it via your system's package manager (e.g.,
`sudo apt install clang-format` on Ubuntu, `brew install llvm` on macOS).
*   **Git**: The version control system, used for repository operations and diffing.
### Python Dependencies
It's recommended to use a virtual environment.
1.  **Create a virtual environment (optional but recommended):**
    ```bash
    python3 -m venv venv
    source venv/bin/activate # On Windows: venv\Scripts\activate
    ```
2.  **Install the required Python packages:**
    ```bash
    pip install PyYAML requests beautifulsoup4 lxml matplotlib
    ```
    *   `PyYAML`: For parsing and generating YAML configurations.
    *   `requests`, `beautifulsoup4`, `lxml`: For scraping `clang-format` documentation to get option values.
    *   `matplotlib`: (Optional) For plotting the fitness history during optimization. If not installed, plotting will be disabled.
## Usage
The optimization process involves two main steps: first, generating a JSON file with `clang-format` option values, and then running the main optimizer.
### Step 1: Generate Clang-Format Option Values
The `get_option_values.py` script scrapes the official `clang-format` style options documentation to create a JSON file containing all known options, their
types, and possible enum values. This file is crucial for the optimizer to know which values to test for each option.
python3 get_option_values.py > data/clang-format-values.json
This command will fetch the latest options from the LLVM documentation and save them to `data/clang-format-values.json`.
### Step 2: (Optional) Define Forced Options
If you have certain `clang-format` options that you always want to keep at a specific value (e.g., `IndentWidth: 4`), you can define them in a YAML file. This
prevents the genetic algorithm from changing these options.
Example `data/forced.yml`:
IndentWidth: 4
UseTab: Never
### Step 3: Run the Optimizer
The `main.py` script is the core of the optimizer. It takes your repository path and the generated option values file as input, then runs the genetic algorithm.
python3 -m src.main <repo_path> [OPTIONS]
**Arguments:**
*   `<repo_path>`: **Required**. Path to the git repository you want to analyze and optimize the `clang-format` configuration for.
**Options:**
*   `--output <file_path>`: Path to the file where the optimized `.clang-format` configuration will be written. If not provided, the output is printed to
`stdout`.
*   `--option-values-json <file_path>`: Path to the JSON file containing `clang-format` options and their possible values (generated by `get_option_values.py`).
*   `--forced-options-yaml <file_path>`: Path to a YAML file containing options that should be forced to a specific value (e.g., `data/forced.yml`).
*   `-d`, `--debug`: Enable debug output, showing commands being executed and more verbose information.
*   `--iterations <int>`: Number of generations for the genetic algorithm (default: `10`). More iterations can lead to better results but take longer.
*   `--population-size <int>`: Total number of individuals across all islands in the genetic algorithm population (default: `50`).
*   `--islands <int>`: Number of independent populations (islands) for the genetic algorithm (default: `1`). Using more islands can help explore the search
space more effectively.
*   `--plot-fitness`: Visualize the best fitness score over time for each island using `matplotlib`.
### Example Usage
To optimize the `clang-format` configuration for a repository located at `/home/user/my_project`, using the generated JSON values and a forced options YAML,
running for 50 iterations with 4 islands, and saving the output to `optimized.clang-format`:
python3 -m src.main /home/user/my_project \
--option-values-json data/clang-format-values.json \
--forced-options-yaml data/forced.yml \
--iterations 50 \
--population-size 100 \
--islands 4 \
--output optimized.clang-format \
--plot-fitness
## How It Works (Briefly)
The optimizer uses a genetic algorithm to find the best `clang-format` configuration.
1.  **Initialization**: A population of random `clang-format` configurations (individuals) is created, based on the default `clang-format --dump-config` output
and the possible values from the JSON file. Forced options are applied.
2.  **Fitness Evaluation**: Each configuration is applied to the target repository. The "fitness" of a configuration is measured by the number of lines changed
(`git diff --shortstat` insertions + deletions). Lower changes mean higher fitness.
3.  **Selection**: Configurations with better fitness (fewer changes) are more likely to be selected for reproduction.
4.  **Crossover**: New configurations (children) are created by combining parts of two parent configurations.
5.  **Mutation**: Random changes are introduced into new configurations to explore new possibilities. This involves picking a random option and testing all its
possible values to find the best one for that specific option.
6.  **Island Model**: The population is divided into several "islands" that evolve independently for a number of generations. Periodically, the best individuals
"migrate" between islands, promoting diversity and preventing premature convergence.
7.  **Iteration**: Steps 2-6 are repeated for a specified number of iterations (generations).
8.  **Result**: The configuration with the overall best fitness (lowest number of changes) found throughout the process is returned as the optimized
configuration.
## Contributing
Contributions are welcome! Please feel free to open issues or pull requests.
## License
This project is licensed under the terms specified in the `LICENSE` file.
